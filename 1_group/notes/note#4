# 객체지향 프로그래밍 정리 7주차

—

개념 이론 정리

- 포인터에 대하여
    
    윤선영 설명 : 포인터는 객체에 접근할 때 가르키는 것으로 인지
    
    최영민 설명 : 포인터란 포인터 변수에 객체의 주소값을 저장하면서 효율적으로 객체에 접근할 수 있도록 하는 방식 
    
    포인터 개념 : 포인터란 메모리 주소를 가리키는 변수로 포인터를 사용할 경우 변수나 데이터 구조체의 메모리 위치에 직접 접근하거나 조작할 수 있으며 메모리 관리와 데이터 구조 조작을 효과적으로 수행할 수 있음
    
    윤선영의 의문 : c의 포인터와 c++의 포인터가 차이점이 있는지?
    
    최영민 대답 : C++의 경우 C언어를 기반으로 만든 언어이기 때문에 아마 개념도 같을 것이라고 추측함
    
    구글에 검색한 결과 : C언어와 C++에서 포인터의 개념은 많은 부분에서 유사하지만  포인터의 초기화 방식, 포인터의 캐스팅, 객체지향의 특징등 포인터를 다루는 방식에서 일부 차이가 존재함 또한 C++은 객체지향 프로그래밍을 지원하고 안전한 포인터 관리를 지원하기 위해서 도구를 제공하지만 C언어는 절자적 프로그래밍에 중점을 두며 포인터 관리와 예외처리를 개발자가 직접 다루어야 함
    
    구글링을 통해 알아보고 느낀 점 
    
    → 윤선영 : C와 C++ 은 포인터가 같은 구조를 보임을 알았고 구글링을 통해 포인터의 개념에 대해 더 자세히 알게 됐고 언제 포인터가 쓰이는지 알게 되었음
    
    → 최영민 : C와 C++에서 포인터는 개념적으로 유사한 구조인것을 확실히 알게 되었고 어떠한 차이점이 존재하는지도 이번 기회를 통해 알게 되었음
    

—

예제 4-1 객체 포인터 선언 및 활용

코딩한 사람 : 윤선영
정리한 사람 : 최영민

- 이 문제의 핵심 포인트
→ 포인터 변수를 활용할줄 아는지 확인하는 것이 핵심포인트라고 생각함
- 이 문제에 대한 접근 방법
    
    → 포인터 변수를 생성하고 포인터 변수에 객체의 주소를 저장하여 변수를 다뤄야 함
    
- 내가 짠 코드
    
    
    Circle *p;
    p = &donut;
    cout << p->getArea() << endl; 
    cout << (*p).getArea() <<endl; 
    
- 코드를 짤때 어려웠던 점
    
    객체 포인터로 멤버를 접근하는데 있어서 c와는 포인터를 사용하는 틀이 같지만 포인터를 사용해서 멤버에 접근 한다는 생각을 하는 것이 힘듦
    
- 실행 결과
    
    3.14
    3.14
    3.14
    2826
    2826
    

---

예제 4-2 Circle 클래스의 배열 선언 및 활용

- 이 문제의 핵심 포인트
배열을 사용하여 포인터에 적용하는 것
- 이 문제에 대한 접근 방법
    
    배열을 생성한 후 배열의 원소에 각각 값을 설정하여 값을 호출하는 방법과 포인터를 선언 후 포인터를 활용해서 배열에 접근하는 방법
    
- 내가 짠 코드
    
    #include <iostream>
    using namespace std;
    
    int main() {
    Circle circleArray[3]; 
    circleArray[0].setRadius(10); 
    circleArray[1].setRadius(20);
    circleArray[2].setRadius(30);
    for(int i=0; i<3; i++) 
    cout << "Circle " << i << "의 면적은 " << circleArray[i].getArea() << endl;
    Circle *p; 
    p = circleArray; 
    for(int i=0; i<3; i++) { 
    cout << "Circle " << i << "의 면적은 " << p->getArea() << endl;
    p++; 
    }
    }
    
- 코드를 짤때 어려웠던 점
    
    이번 실습을 통해서 포인터를 통해 배열에 접근할 수 있다는 점을 알게 되었고 포인터를 사용하여 배열에 접근하는 방식이 간단한 과정에서는 좀 더 복잡하다고  느껴질 수 있으나 배열의 크기가 커질 수록 포인터를 사용하여 배열에 접근 하는 방식이 편리할 것 같다는 생각을 하게 됨
    
- 실행 결과
    
    Circle 0의 면적은 314
    Circle 1의 면적은 1256
    Circle 2의 면적은 2826
    Circle 0의 면적은 314
    Circle 1의 면적은 1256
    Circle 2의 면적은 2826
    
- 교수님 말씀 중요한 것
    
    → 배열도 포인터 이기 때문에 p = circleArrary;가 맞는 표현이다.
    

---

예제 4-3 객체 배열 초기화

- 이 문제의 핵심 포인트
→ 객체 배열도 초기화가 진행된다는 것을 인지하는 것이 핵심 포인트
- 이 문제에 대한 접근 방법
    
    → 인자값이 없을 경우 초기화 되는 값과 인자값이 있을 경우 초기화 될 값을 설정하고 그 이후에 메인함수에서 초기화를 진행해주는 순서로 코드를 작성
    
- 내가 짠 코드
    
    #include <iostream>
    using namespace std;
    class Circle {
    int radius;
    public:
    Circle() { radius = 1; }
    Circle(int r) { radius = r; }
    void setRadius(int r) { radius = r; }
    double getArea();
    };
    double Circle::getArea() {
    return 3.14*radius*radius;
    }
    int main() {
    Circle circleArray[3] = { Circle(10), Circle(20), Circle() };
    for(int i=0; i<3; i++)
    cout << "Circle " << i << "의 면적은 " << circleArray[i].getArea() << endl;
    }
    
- 코드를 짤때 어려웠던 점
    
    → 인자값이 없을 때는 컴파일러가 자동으로 생성자를 생성해줘서 코드가 비교적 간편했는데 이번 코드에서는 인자값이 있는 경우와 없는 경우 모두 존재하여 신경쓸 것이 많아진 것이 어려웠음
    
- 실행 결과
    
    Circle 0의 면적은 314
    Circle 1의 면적은 1256
    Circle 2의 면적은 3.14
    

---

예제 4-4 Circle 클래스의 2차원 배열 선언 및 활용

- 이 문제의 핵심 포인트
→ 2차원 배열 사용시 배열 구조를 생각하고 사용해야함
- 이 문제에 대한 접근 방법
    
    → 배열을 먼저 초기화 ( 2차원 배열임을 주의 ) 위의 문제와 접근 방식 거의 동일
    
- 내가 짠 코드
    
    #include <iostream>
    using namespace std;
    class Circle {
    int radius;
    public:
    Circle() { radius = 1; }
    Circle(int r) { radius = r; }
    void setRadius(int r) { radius = r; }
    double getArea();
    };
    double Circle::getArea() {
    return 3.14*radius*radius;
    }
    
    #include <iostream>
    using namespace std;
    
    int main() {
    Circle circles[2][3];
    circles[0][0].setRadius(1);
    circles[0][1].setRadius(2);
    circles[0][2].setRadius(3);
    circles[1][0].setRadius(4);
    circles[1][1].setRadius(5);
    circles[1][2].setRadius(6);
    for(int i=0; i<2; i++)
    for(int j=0; j<3; j++) {
    cout << "Circle [" << i << "," << j << "]의 면적은 ";
    cout << circles[i][j].getArea() <<endl;
    }
    }
    
- 코드를 짤때 어려웠던 점
    
    → 배열이 2차원 배열이라는 점을 제외하고 위 문제와 동일 했기 때문에 2차원 배열을 초기화 하는데 신경쓰면서 코딩함
    
- 실행 결과
    
    Circle [0,0]의 면적은 3.14
    Circle [0,1]의 면적은 12.56
    Circle [0,2]의 면적은 28.26
    Circle [1,0]의 면적은 50.24
    Circle [1,1]의 면적은 78.5
    Circle [1,2]의 면적은 113.04
    

---

예제 4-5 정수형 공간의 동적 할당 및 반환 예

- 이 문제의 핵심 포인트
    - 조건문을 활용하여 할당이 되어있는지 확인하는 것
    - *p 가 포인터가 아니라 포인터가 가리키는 값을 의미한다는 것을 인지하는 지
    - 포인터를 new 로 생성하는 것과 delete로 반환하는 것
- 이 문제에 대한 접근 방법
    
    → 조건문으로 할당이 되었을 경우에만 다음 로직이 진행되도록 하고 new 로 생성한 포인터 변수에 값을 직접적으로 삽입하고 delete로 할당 받은 메모리 반환
    
- 내가 짠 코드
    
    #include <iostream>
    using namespace std;
    
    int main() {
    int *p;
    p = new int;
    if(!p) {
    cout << "메모리를 할당할 수 없습니다.";
    return 0;
    }
    
    *p = 5;
    int n = *p;
    cout << "*p = " << *p << '\n';
    cout << "n = " << n << '\n';
    delete p;
    }
    
- 코드를 짤때 어려웠던 점
    
    if(!p) 부분에서 p가 null일 경우를 생각하여 조건문을 사용해야하는 것을 신경써야 하고 delete를 사용하여 메모리를 반환하는 것에 대한 개념을 자세히 알아야 실습에서 사용 가능함
    
- 실행 결과
    - p = 5
    n = 5

---

예제 4-6 정수형 배열의 동적 할당 및 반환

- 이 문제의 핵심 포인트
→ 배열도 동적 할당이 가능한 것을 배울 수 있는 예제 코드임
    
    → 동적할당을 진행했기 때문에 delete 처리 해주어야함
    
- 이 문제에 대한 접근 방법
    1. 사용자로부터 입력할 정수의 개수를 입력받는 함수
    2. 배열을 동적 할당으로 선언
    3. 정수를 하나씩 입력 받음
    4. 합을 출력하는 프로그램 작성
- 내가 짠 코드
    
    #include <iostream>
    using namespace std;
    
    int main() {
    cout << "입력할 정수의 개수는?";
    int n;
    cin >> n;
    if(n <= 0) return 0;
    int *p = new int[n];
    if(!p) {
    cout << "메모리를 할당할 수 없습니다.";
    return 0;
    }
    for(int i=0; i<n; i++) {
    cout << i+1 << "번째 정수: ";
    cin >> p[i];
    }
    int sum = 0;
    for(int i=0; i<n; i++)
    sum += p[i];
    cout << "평균 = " << sum/n << endl;
    delete [] p;
    }
    
- 코드를 짤때 어려웠던 점
    
    위에서 배웠던 동적 할당과 유사하나 배열을 동적할당 했다는 점에서 차이가 있는 문제임을 알고 있었기 때문에 배열을 동적할당 해줄때 신경써서 진행함
    
- 실행 결과
    
    입력할 정수의 개수는? 3
    1번째 정수: 5
    2번째 정수: 4
    3번째 정수: 10
    평균 = 6
    

---

예제 4-10 객체 배열의 동적 생성과 반환 응용

- 이 문제의 핵심 포인트
→ 객체 배열을 동적으로 생성하고 반환하는 과정을 연습하는 코드
- 이 문제에 대한 접근 방법
    
    포인터로 배열을 가리키면서 배열을 생성하고 그 배열을 사용하여 객체 멤버에 접근함
    
- 내가 짠 코드
    
    #include <iostream>
    using namespace std;
    
    int main() {
    cout << "생성하고자 하는 원의 개수?";
    int n, radius;
    cin >> n; 
    Circle *pArray = new Circle [n]; 
    for(int i=0; i<n; i++) {
    cout << "원" << i+1 << ": "; 
    cin >> radius;
    pArray[i].setRadius(radius); 
    }
    int count =0; 
    Circle* p = pArray;
    for(int i=0; i<n; i++) {
    cout << p->getArea() << ' '; 
    if(p->getArea() >= 100 && p->getArea() <= 200)
    count++;
    p++;
    }
    cout << endl << "면적이 100에서 200 사이인 원의 개수는 "
    << count << endl;
    delete [] pArray; 
    }
    
- 코드를 짤때 어려웠던 점
    
    → 같은 코드형태의 코드를 반복중이며 이번에는 객체 배열의 동적 생성과 반환을 연습하는 코드이므로 객체 배열의 동적 생성과 반환에 신경쓰면서 코딩
    
- 실행 결과
    
    생성하고자 하는 원의 개수?4
    원1: 5
    원2: 6
    원3: 7
    원4: 8
    78.5 113.04 153.86 200.96
    면적이 100에서 200 사이인 원의 개수는 2
